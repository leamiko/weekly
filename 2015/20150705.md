###苏州市融合通信重点实验室周报(6月29日——7月5日)
	作者：姚善良 iat                   小组：PHP                        时间：2015年7月5日
###进度报告
#####本周完成的事情
* 统一身份认证的初步编码
* weiphp的一处bug
* 期末考试

#####待解决问题及下一步计划
* 统一身份认证实现同步登陆，给出接口文档
* 期末考试

###简述
* 查找了很多关于“统一身份认证”的案例，也对比了很多方法。发现其实并不像想象中的那么简单的，不是post用户名密码，返回true就允许登陆的。

* 统一身份认证大致流程如下：
 
 * 1、用户使用在统一认证服务注册的用户名和密码(也可能是其他的授权信息，比如数字签名等)登陆统一认证服务；

 * 2、统一认证服务创建了一个会话，同时将与该会话关联的访问认证令牌返回给用户；

 * 3、用户使用这个访问认证令牌访问某个支持统一身份认证服务的应用系统；

 * 4、该应用系统将访问认证令牌传入统一身份认证服务，认证访问认证令牌的有效性；

 * 5、统一身份认证服务确认认证令牌的有效性；

 * 6、应用系统接收访问，并返回访问结果，如果需要提高访问效率的话，应用系统可选择返回其自身的认证令牌已使得用户之后可以使用这个私有令牌持续访问。

* 上面所说的令牌可以用COOKIE或者SEESION来实现。

 * 通过COOKIE来实现

   	 * 1、用户在统一登录页登陆，通过查询主用户数据库判断用户是否合法，若是，则注册该用户的唯一COOKIE标识（可以通过加密用户名和密码得到，网上有很多算法）。

	 * 2、用户进入某子系统时，先判断COOKIE是否注册，若注册了 ，则解密该COOKIE得到用户名和帐号，并判断合法性。

	 * 3、如果合法，则立刻在该子系统中注册（可在原子系统的登录脚本种抽出登录的部分做成一个函数）

		使用COOKIE的优点就是简单，只要设置一下就可以实现COOKIE的跨子域传递，例如：

			setcookie(USER_COOKIE, 用户名, 失效时间, 作用路径, '.a.com');

		就能实现在所有.a.com子域下的传递。

		但COOKIE也有他的缺点，首先就是安全级别不高，要提防COOKIE劫持的威胁，其次就是它只能跨子域传递，而不能跨完全不同的域。比如说a.com和b.com之间就不能传递。

 * 通过SESSION实现
 	
		由于SESSION是存储在服务器端的，所以安全级别肯定要比COOKIE的级别高。但是由于SEESION存储的位置不同，造成了无法跨域传递 。可以通过把SEESION村入数据库来解决这个问题。

		* 由于PHP的SESSION需要用到标识SESSION的COOKIE，所以需要设置下COOKIE的作用域

			ini\_set('session.cookie_domain', '.a.com');


		* 然后重写PHP的SESSION操作函数。PHP 提供了session\_set\_save\_handle() 函数来自定义 SESSION 的处理过程，先将 session.save_handler 改成 user

			session\_module\_name('user');
		
		* （然后网上找个好点的PHP将SESSION写入数据库的代码吧）

